<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Mini Tetris 8x8 Drag & Drop</title>
<style>
body {
  display: flex;
  flex-direction: column;
  align-items: center;
  background: #222;
  color: #fff;
  font-family: sans-serif;
  padding-top: 20px;
}
#score { font-size: 24px; margin-bottom: 10px; }
#game {
  display: grid;
  grid-template-columns: repeat(8, 40px);
  grid-template-rows: repeat(8, 40px);
  gap: 2px;
  margin-bottom: 20px;
  position: relative;
}
.cell { width: 40px; height: 40px; background: #333; transition: background 0.3s; }
.filled { background: #0f0; }
#blocks { display: flex; gap: 20px; margin-bottom: 20px; min-height: 90px; }
.block { cursor: grab; position: relative; display: flex; flex-wrap: wrap; }
.block-cell { width: 40px; height: 40px; background: #0f0; margin: 2px; }
</style>
</head>
<body>
<div id="score">Очки: 0</div>
<div id="game"></div>
<div id="blocks"></div>

<script>
const width = 8;
const gridElem = document.getElementById('game');
const blocksDiv = document.getElementById('blocks');
const scoreDisplay = document.getElementById('score');
let gridState = [];
let score = 0;
let placedCount = 0;

// Создаем игровое поле и массив состояния
for(let y=0;y<width;y++){
  gridState[y]=[];
  for(let x=0;x<width;x++){
    const cell = document.createElement('div');
    cell.classList.add('cell');
    gridElem.appendChild(cell);
    gridState[y][x] = 0;
  }
}

// Блоки как массив координат относительно левого верхнего угла
const blocksData = [
  [[0,0]],                 // 1x1
  [[0,0],[1,0]],           // горизонтальная 2x1
  [[0,0],[0,1]],           // вертикальная 1x2
  [[0,0],[1,0],[0,1]]      // L-образная
];

// Генерация 3 блоков
function generateBlocks(){
  blocksDiv.innerHTML = '';
  placedCount = 0;
  for(let i=0;i<3;i++){
    const b = blocksData[Math.floor(Math.random()*blocksData.length)];
    createBlockElement(b);
  }
}

// Создание DOM блока для drag
function createBlockElement(blockShape){
  const block = document.createElement('div');
  block.classList.add('block');
  block.dataset.width = Math.max(...blockShape.map(c=>c[0]))+1;
  block.dataset.height = Math.max(...blockShape.map(c=>c[1]))+1;
  
  // Создаем клетки блока
  blockShape.forEach(c=>{
    const cell = document.createElement('div');
    cell.classList.add('block-cell');
    block.appendChild(cell);
  });
  
  blocksDiv.appendChild(block);
  makeDraggable(block, blockShape);
}

// Drag & Drop
function makeDraggable(block, shape){
  block.onmousedown = function(e){
    e.preventDefault();
    let shiftX = e.clientX - block.getBoundingClientRect().left;
    let shiftY = e.clientY - block.getBoundingClientRect().top;
    block.style.position = 'absolute';
    block.style.zIndex = 1000;
    document.body.append(block);

    function moveAt(pageX,pageY){
      block.style.left = pageX - shiftX + 'px';
      block.style.top = pageY - shiftY + 'px';
    }
    moveAt(e.pageX,e.pageY);

    function onMouseMove(e){
      moveAt(e.pageX,e.pageY);
    }
    document.addEventListener('mousemove', onMouseMove);

    block.onmouseup = function(e){
      document.removeEventListener('mousemove', onMouseMove);
      block.onmouseup=null;

      const gameRect = gridElem.getBoundingClientRect();
      const x = Math.floor((e.clientX - gameRect.left)/42);
      const y = Math.floor((e.clientY - gameRect.top)/42);

      if(canPlace(shape, x, y)){
        placeBlock(shape, x, y);
        score +=10;
        placedCount++;
        checkFullLines();
        updateScore();
        block.remove();
        if(placedCount>=3) generateBlocks();
      } else {
        // возвращаем на панель
        block.style.position='';
        block.style.left='';
        block.style.top='';
        block.style.zIndex='';
        blocksDiv.appendChild(block);
      }
    };
  };
  block.ondragstart = ()=>false;
}

// Проверка возможности поставить блок
function canPlace(block,x,y){
  return block.every(c=>{
    const gx = x+c[0];
    const gy = y+c[1];
    if(gx<0||gx>=width||gy<0||gy>=width) return false;
    return gridState[gy][gx]===0;
  });
}

// Размещение блока
function placeBlock(block,x,y){
  block.forEach(c=>{
    const gx = x+c[0];
    const gy = y+c[1];
    gridState[gy][gx]=1;
    gridElem.children[gy*width+gx].classList.add('filled');
  });
}

// Проверка линий
function checkFullLines(){
  let toRemove=[];
  // Горизонтальные
  for(let y=0;y<width;y++){
    if(gridState[y].every(c=>c===1)) for(let x=0;x<width;x++) toRemove.push([x,y]);
  }
  // Вертикальные
  for(let x=0;x<width;x++){
    let full=true;
    for(let y=0;y<width;y++) if(gridState[y][x]===0) full=false;
    if(full) for(let y=0;y<width;y++) toRemove.push([x,y]);
  }
  if(toRemove.length>0) score+=20;

  // Анимация удаления
  toRemove.forEach(([x,y])=>gridElem.children[y*width+x].style.background='#f00');
  setTimeout(()=>{
    toRemove.forEach(([x,y])=>{
      gridState[y][x]=0;
      gridElem.children[y*width+x].classList.remove('filled');
      gridElem.children[y*width+x].style.background='#333';
    });
  },300);
}

function updateScore(){ scoreDisplay.textContent='Очки: '+score; }

generateBlocks();
</script>
</body>
</html>
