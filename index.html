<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Mini Tetris 8x8</title>
<style>
  body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background: #222;
    color: #fff;
    font-family: sans-serif;
  }
  #game {
    display: grid;
    grid-template-columns: repeat(8, 40px);
    grid-template-rows: repeat(8, 40px);
    gap: 2px;
  }
  .cell {
    width: 40px;
    height: 40px;
    background: #333;
    transition: background 0.3s;
  }
  .filled {
    background: #0f0;
  }
</style>
</head>
<body>
<div>
  <div id="game"></div>
  <button id="next">Добавить блоки</button>
</div>

<script>
const game = document.getElementById('game');
const width = 8;
let grid = [];

// Инициализация сетки
for(let i=0;i<64;i++){
  const cell = document.createElement('div');
  cell.classList.add('cell');
  game.appendChild(cell);
  grid.push(cell);
}

// Примеры блоков (1x1 или 2x1)
const blocks = [
  [[1]],           // 1x1
  [[1,1]],         // 1x2 горизонтально
  [[1],[1]],       // 2x1 вертикально
  [[1,1],[1,0]]    // L-образная
];

// Функция добавления блоков снизу
function addBlocks(){
  let added = 0;
  while(added < 3){
    const block = blocks[Math.floor(Math.random()*blocks.length)];
    const bw = block[0].length;
    const bh = block.length;
    const x = Math.floor(Math.random() * (width - bw + 1));
    const y = 7 - bh + 1; // снизу
    if(canPlace(block,x,y)){
      placeBlock(block,x,y);
      added++;
    }
  }
  checkFullLines();
}

// Проверка возможности поставить блок
function canPlace(block,x,y){
  for(let r=0;r<block.length;r++){
    for(let c=0;c<block[0].length;c++){
      if(block[r][c]){
        const idx = (y+r)*width + (x+c);
        if(grid[idx].classList.contains('filled')) return false;
      }
    }
  }
  return true;
}

// Установка блока
function placeBlock(block,x,y){
  for(let r=0;r<block.length;r++){
    for(let c=0;c<block[0].length;c++){
      if(block[r][c]){
        const idx = (y+r)*width + (x+c);
        grid[idx].classList.add('filled');
      }
    }
  }
}

// Проверка горизонтальных и вертикальных линий
function checkFullLines(){
  let toRemove = [];
  
  // Горизонтальные
  for(let r=0;r<width;r++){
    let full = true;
    for(let c=0;c<width;c++){
      if(!grid[r*width + c].classList.contains('filled')) full=false;
    }
    if(full){
      for(let c=0;c<width;c++) toRemove.push(r*width+c);
    }
  }
  
  // Вертикальные
  for(let c=0;c<width;c++){
    let full = true;
    for(let r=0;r<width;r++){
      if(!grid[r*width + c].classList.contains('filled')) full=false;
    }
    if(full){
      for(let r=0;r<width;r++) toRemove.push(r*width+c);
    }
  }

  // Анимация исчезновения
  toRemove.forEach(idx => {
    grid[idx].style.background = '#f00';
  });
  setTimeout(() => {
    toRemove.forEach(idx => grid[idx].classList.remove('filled'));
    toRemove.forEach(idx => grid[idx].style.background = '#333');
  }, 300);
}

document.getElementById('next').addEventListener('click', addBlocks);
</script>
</body>
</html>
