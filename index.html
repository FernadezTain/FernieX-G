<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Mini Tetris 8x8 Drag & Drop</title>
<style>
body {
  display: flex;
  flex-direction: column;
  align-items: center;
  background: #222;
  color: #fff;
  font-family: sans-serif;
  padding-top: 20px;
}
#score { font-size: 24px; margin-bottom: 10px; }
#game {
  display: grid;
  grid-template-columns: repeat(8, 40px);
  grid-template-rows: repeat(8, 40px);
  gap: 2px;
  margin-bottom: 20px;
  position: relative;
}
.cell { width: 40px; height: 40px; background: #333; transition: background 0.3s; }
.filled { background: #0f0; }
#blocks { display: flex; gap: 20px; margin-bottom: 10px; }
.block { position: absolute; cursor: grab; }
.block-cell { width: 40px; height: 40px; background: #0f0; float: left; margin: 2px; }
</style>
</head>
<body>
<div id="score">Очки: 0</div>
<div id="game"></div>
<div id="blocks"></div>

<script>
const width = 8;
const gridElem = document.getElementById('game');
const blocksDiv = document.getElementById('blocks');
const scoreDisplay = document.getElementById('score');
let grid = [];
let score = 0;
let placedCount = 0;

// Создаем игровое поле 8x8
for(let i=0;i<64;i++){
  const cell = document.createElement('div');
  cell.classList.add('cell');
  gridElem.appendChild(cell);
  grid.push(cell);
}

// Блоки как массив координат относительно левого верхнего угла
const blocksData = [
  [[0,0]],                 // 1x1
  [[0,0],[1,0]],           // 2 горизонтально
  [[0,0],[0,1]],           // 2 вертикально
  [[0,0],[1,0],[0,1]]      // L-образная
];

function generateBlocks(){
  blocksDiv.innerHTML = '';
  placedCount = 0;
  for(let i=0;i<3;i++){
    const b = blocksData[Math.floor(Math.random()*blocksData.length)];
    createBlockElement(b);
  }
}

// Создание DOM блока для drag
function createBlockElement(blockShape){
  const block = document.createElement('div');
  block.classList.add('block');
  document.body.appendChild(block);
  
  // Определяем размер блока
  let maxX = Math.max(...blockShape.map(c=>c[0]));
  let maxY = Math.max(...blockShape.map(c=>c[1]));
  block.style.width = (maxX+1)*42 + 'px';
  block.style.height = (maxY+1)*42 + 'px';
  
  // Создаем клетки
  blockShape.forEach(c=>{
    const cell = document.createElement('div');
    cell.classList.add('block-cell');
    cell.style.position = 'absolute';
    cell.style.left = c[0]*42 + 'px';
    cell.style.top = c[1]*42 + 'px';
    block.appendChild(cell);
  });

  makeDraggable(block, blockShape);
}

// Drag & Drop
function makeDraggable(block, shape){
  block.onmousedown = function(e){
    e.preventDefault();
    let shiftX = e.clientX - block.getBoundingClientRect().left;
    let shiftY = e.clientY - block.getBoundingClientRect().top;
    block.style.zIndex = 1000;

    moveAt(e.pageX, e.pageY);

    function moveAt(pageX, pageY){
      block.style.left = pageX - shiftX + 'px';
      block.style.top = pageY - shiftY + 'px';
    }

    function onMouseMove(e){
      moveAt(e.pageX, e.pageY);
    }

    document.addEventListener('mousemove', onMouseMove);

    block.onmouseup = function(e){
      document.removeEventListener('mousemove', onMouseMove);
      block.onmouseup = null;

      const gameRect = gridElem.getBoundingClientRect();
      const x = Math.floor((e.clientX - gameRect.left)/42);
      const y = Math.floor((e.clientY - gameRect.top)/42);

      if(canPlace(shape, x, y)){
        placeBlock(shape, x, y);
        score += 10;
        placedCount++;
        checkFullLines();
        updateScore();
        block.remove();
        if(placedCount>=3) generateBlocks();
      } else {
        // возвращаем на панель
        block.style.left = '';
        block.style.top = '';
        block.style.position = '';
        block.style.zIndex = '';
        blocksDiv.appendChild(block);
      }
    };
  };
  block.ondragstart = () => false;
}

function canPlace(block, x, y){
  return block.every(c=>{
    const gx = x + c[0];
    const gy = y + c[1];
    if(gx<0 || gx>=width || gy<0 || gy>=width) return false;
    const idx = gy*width + gx;
    return !grid[idx].classList.contains('filled');
  });
}

function placeBlock(block, x, y){
  block.forEach(c=>{
    const idx = (y+c[1])*width + (x+c[0]);
    grid[idx].classList.add('filled');
  });
}

function checkFullLines(){
  let toRemove=[];
  for(let r=0;r<width;r++){
    let full=true;
    for(let c=0;c<width;c++){
      if(!grid[r*width+c].classList.contains('filled')) full=false;
    }
    if(full) for(let c=0;c<width;c++) toRemove.push(r*width+c);
  }
  for(let c=0;c<width;c++){
    let full=true;
    for(let r=0;r<width;r++){
      if(!grid[r*width+c].classList.contains('filled')) full=false;
    }
    if(full) for(let r=0;r<width;r++) toRemove.push(r*width+c);
  }
  if(toRemove.length>0){ score+=20; updateScore(); }
  toRemove.forEach(idx => grid[idx].style.background='#f00');
  setTimeout(()=>{
    toRemove.forEach(idx=>grid[idx].classList.remove('filled'));
    toRemove.forEach(idx=>grid[idx].style.background='#333');
  },300);
}

function updateScore(){ scoreDisplay.textContent = 'Очки: '+score; }

generateBlocks();
</script>
</body>
</html>
