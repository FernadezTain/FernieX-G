<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Mini Tetris 8x8 - Очки</title>
<style>
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    background: #222;
    color: #fff;
    font-family: sans-serif;
    padding-top: 20px;
  }
  #score {
    font-size: 24px;
    margin-bottom: 10px;
  }
  #game {
    display: grid;
    grid-template-columns: repeat(8, 40px);
    grid-template-rows: repeat(8, 40px);
    gap: 2px;
    margin-bottom: 20px;
  }
  .cell {
    width: 40px;
    height: 40px;
    background: #333;
    transition: background 0.3s;
  }
  .filled {
    background: #0f0;
  }
  #blocks {
    display: flex;
    gap: 20px;
    margin-bottom: 10px;
  }
  .block {
    display: grid;
    grid-template-columns: repeat(2, 30px);
    grid-template-rows: repeat(2, 30px);
    gap: 2px;
    cursor: pointer;
  }
  .block .cell {
    background: #555;
  }
  .block .filled {
    background: #0f0;
  }
</style>
</head>
<body>
<div id="score">Очки: 0</div>
<div id="game"></div>
<div id="blocks"></div>

<script>
const width = 8;
const game = document.getElementById('game');
const scoreDisplay = document.getElementById('score');
let grid = [];
let score = 0;
let placedCount = 0;

// Создаем игровое поле
for(let i=0;i<64;i++){
  const cell = document.createElement('div');
  cell.classList.add('cell');
  game.appendChild(cell);
  grid.push(cell);
}

// Примеры блоков (до 2x2 для простоты)
const blocks = [
  [[1]],
  [[1,1]],
  [[1],[1]],
  [[1,1],[1,0]]
];

let currentBlocks = [];

// Генерация 3 блоков
function generateBlocks(){
  const blocksDiv = document.getElementById('blocks');
  blocksDiv.innerHTML = '';
  currentBlocks = [];
  placedCount = 0;

  for(let i=0;i<3;i++){
    const b = blocks[Math.floor(Math.random()*blocks.length)];
    currentBlocks.push(b);
    const div = document.createElement('div');
    div.classList.add('block');
    div.dataset.index = i;
    for(let r=0;r<2;r++){
      for(let c=0;c<2;c++){
        const cell = document.createElement('div');
        cell.classList.add('cell');
        if(b[r] && b[r][c]) cell.classList.add('filled');
        div.appendChild(cell);
      }
    }
    blocksDiv.appendChild(div);

    div.addEventListener('click', () => {
      selectBlock(i);
    });
  }
}

// Выбор блока
function selectBlock(idx){
  const block = currentBlocks[idx];
  let x = prompt('Введите X (0-7) для верхнего левого угла блока:');
  let y = prompt('Введите Y (0-7) для верхнего левого угла блока:');
  x = parseInt(x); y = parseInt(y);
  if(canPlace(block,x,y)){
    placeBlock(block,x,y);
    score += 10; // +10 за каждый блок
    placedCount++;
    checkFullLines();
    updateScore();
    // Если поставлено 3 блока, генерируем новые
    if(placedCount >= 3){
      generateBlocks();
    }
  } else {
    alert('Нельзя разместить блок здесь!');
  }
}

// Проверка возможности поставить блок
function canPlace(block,x,y){
  for(let r=0;r<block.length;r++){
    for(let c=0;c<block[0].length;c++){
      if(block[r][c]){
        const gx = x+c;
        const gy = y+r;
        if(gx<0 || gx>=width || gy<0 || gy>=width) return false;
        const idx = gy*width + gx;
        if(grid[idx].classList.contains('filled')) return false;
      }
    }
  }
  return true;
}

// Размещение блока
function placeBlock(block,x,y){
  for(let r=0;r<block.length;r++){
    for(let c=0;c<block[0].length;c++){
      if(block[r][c]){
        const idx = (y+r)*width + (x+c);
        grid[idx].classList.add('filled');
      }
    }
  }
}

// Проверка линий и начисление очков
function checkFullLines(){
  let toRemove = [];

  // Горизонтальные
  for(let r=0;r<width;r++){
    let full = true;
    for(let c=0;c<width;c++){
      if(!grid[r*width + c].classList.contains('filled')) full=false;
    }
    if(full) for(let c=0;c<width;c++) toRemove.push(r*width+c);
  }

  // Вертикальные
  for(let c=0;c<width;c++){
    let full = true;
    for(let r=0;r<width;r++){
      if(!grid[r*width + c].classList.contains('filled')) full=false;
    }
    if(full) for(let r=0;r<width;r++) toRemove.push(r*width+c);
  }

  if(toRemove.length > 0){
    score += 20; // +20 за заполненную линию
    updateScore();
  }

  // Анимация удаления
  toRemove.forEach(idx => grid[idx].style.background = '#f00');
  setTimeout(() => {
    toRemove.forEach(idx => grid[idx].classList.remove('filled'));
    toRemove.forEach(idx => grid[idx].style.background = '#333');
  }, 300);
}

// Обновление счетчика
function updateScore(){
  scoreDisplay.textContent = 'Очки: ' + score;
}

// Запуск игры
generateBlocks();
</script>
</body>
</html>
